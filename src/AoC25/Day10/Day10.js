const {
  getData,
  Queue,
  PriorityQueue,
} = require('../../Utils/globalFunctions.js');
const { parseStringOfInts } = require('../../Utils/parse.js');
const { sum } = require('../../Utils/maths.js');

// https://adventofcode.com/2025/day/10

// DAY=10 npm run 2025
const formatData = async (filepath) => {
  const data = await getData(filepath);
  const machines = data.split('\n');

  let formatted = [];

  for (const machine of machines) {
    const firstSplit = machine.indexOf(']');
    const secondSplit = machine.lastIndexOf(')') + 1;
    const lightDiagram = machine.slice(1, firstSplit).split('');
    const buttonSchematics = machine
      .slice(firstSplit + 2, secondSplit)
      .match(/(?<=\().*?(?=\))/g)
      .map((button) => parseStringOfInts(button, ','));
    const joltageRequirement = parseStringOfInts(
      machine.slice(secondSplit + 2, machine.length - 1),
      ','
    );

    formatted.push({ lightDiagram, buttonSchematics, joltageRequirement });
  }
  return formatted;
};

const maskLightDiagram = (diagram) => {
  return diagram.reduce((mask, char, i) => {
    return char === '#' ? mask | (1 << i) : mask;
  }, 0);
};

const maskButtonSchematic = (button) => {
  // start with 0000
  let mask = 0;
  for (const lightIndex of button) {
    // set the bit at lightIndex to 1
    mask |= 1 << lightIndex;
  }
  return mask;
};

// Part One

const fewestButtonPressesForLights = (lightDiagram, buttonSchematics) => {
  const buttonMasks = buttonSchematics.map((button) =>
    maskButtonSchematic(button)
  );
  const targetMask = maskLightDiagram(lightDiagram);

  const visited = new Map();
  visited.set(0, 0);

  const queue = new Queue();
  queue.enqueue(0);

  while (!queue.isEmpty()) {
    const currentLightState = queue.front();
    const currentNumPresses = visited.get(currentLightState);

    // don't repeat button presses - they cancel each other out
    if (currentNumPresses >= buttonMasks.length) continue;

    for (const button of buttonMasks) {
      // toggle lights
      const nextLightState = currentLightState ^ button;
      const nextNumPresses = currentNumPresses + 1;

      if (nextLightState === targetMask) {
        return nextNumPresses;
      }

      if (!visited.has(nextLightState)) {
        visited.set(nextLightState, nextNumPresses);
        queue.enqueue(nextLightState);
      }
    }
    queue.dequeue();
  }
};

const partOne = async (input) => {
  const buttonPresses = input.map((machine) =>
    fewestButtonPressesForLights(machine.lightDiagram, machine.buttonSchematics)
  );

  return sum(buttonPresses);
};

// Part Two

/**
 *
 * @param {*} buttonSchematics
 * @param {*} targetJoltage
 * @returns a map where key is an index in target joltage and the value is an array of the buttons from buttonSchematics that increment that joltage index
 */
const getButtonMap = (buttonSchematics, targetJoltage) => {
  const numJoltageIndexes = targetJoltage.length;

  const buttonsPerJoltageIndex = new Map();

  for (let i = 0; i < numJoltageIndexes; i++) {
    buttonsPerJoltageIndex.set(
      i,
      buttonSchematics.filter((button) => button.includes(i))
    );
  }
  return buttonsPerJoltageIndex;
};

//
//
/**
 * creates a map where the key is the index of an element in targetJoltage
 * and the value is the value of the element at that index
 * sorted into ascending order by value to allow us to iterate
 * on targetJoltage elements from lowest value to highest
 *
 * The first element in the map output by this function
 * should be the key/value pair for the lowest value element in targetJoltage
 * @param {*} targetJoltage
 * @returns Map() { i => targetJoltage[i] }
 */
const mapJoltageMaximums = (targetJoltage) => {
  return new Map(
    Array.from(targetJoltage.entries()).sort((a, b) => a[1] - b[1])
  );
};

const joltageTargetMet = (maxJoltageMap, state) => {
  return state.every((value, i) => value === maxJoltageMap.get(i));
};

/**
 * determines whether any element in the current state
 * has exceeded the maximum allowed value at that index
 * @param {*} maxJoltageMap map generated by mapJoltageMaximums
 * @param {*} state
 * @returns boolean
 */
const joltageTargetExceeded = (maxJoltageMap, state) => {
  return state.some((value, i) => value > maxJoltageMap.get(i));
};

const pressButton = (button, state) => {
  let newState = [...state];
  for (const i of button) {
    newState[i]++;
  }
  return newState;
};

const getButtonsToPress = (buttonMap, state, maxJoltageMap) => {
  const findLowestUnmaxedIndex = () => {
    for (const [key, value] of maxJoltageMap) {
      if (value > state[key]) {
        return key;
      }
    }
  };

  const nextIndex = findLowestUnmaxedIndex();

  // filter out buttons that cannot be pressed because they
  // increment an index that has already hit max joltage

  return buttonMap
    .get(nextIndex)
    .filter((button) => !button.some((i) => state[i] === maxJoltageMap.get(i)));
};

const comparator = (a, b) => {
  // prioritize fewer button presses if button presses are different
  if (a.numButtonPresses !== b.numButtonPresses) {
    return a.numButtonPresses < b.numButtonPresses;
  }

  // prioritize by higher sum (closer to target) if button presses are the same
  return a.sum > b.sum;
};

const fewestButtonPressesForJoltage = (targetJoltage, buttonSchematics) => {
  const maxJoltageMap = mapJoltageMaximums(targetJoltage);
  const buttonMap = getButtonMap(buttonSchematics, targetJoltage);
  const initialState = Array(targetJoltage.length).fill(0);

  const visited = new Set();
  visited.add(JSON.stringify(initialState));

  // TODO: Replace with Priority Queue
  const pQueue = new PriorityQueue(comparator);

  pQueue.push({
    currentState: initialState,
    numButtonPresses: 0,
    sum: 0,
  });

  while (!pQueue.isEmpty()) {
    const { currentState, numButtonPresses } = pQueue.pop();
    let buttonsToPress = getButtonsToPress(
      buttonMap,
      currentState,
      maxJoltageMap
    );

    for (const button of buttonsToPress) {
      let newState = pressButton(button, currentState);
      let newNumButtonPresses = numButtonPresses + 1;

      if (joltageTargetExceeded(maxJoltageMap, newState)) {
        continue;
      }

      if (joltageTargetMet(maxJoltageMap, newState)) {
        return newNumButtonPresses;
      }

      if (!visited.has(JSON.stringify(newState))) {
        visited.add(JSON.stringify(newState));
        pQueue.push({
          currentState: newState,
          numButtonPresses: newNumButtonPresses,
          sum: sum(newState),
        });
      }
    }
  }
};

const partTwo = async (input) => {
  return sum(
    input.map((machine) =>
      fewestButtonPressesForJoltage(
        machine.joltageRequirement,
        machine.buttonSchematics
      )
    )
  );
};

const solve = async () => {
  const dataPath = require.resolve(
    '../../../src/AoC25/puzzleInputs/Day10Input.txt'
  );

  try {
    const formattedData = await formatData(dataPath);
    const results = await Promise.all([
      await partOne(formattedData),
      await partTwo(formattedData),
    ]);
    console.log('\n' + 'Day 10');
    console.log(results);
    return results;
  } catch (err) {
    console.log(err);
  }
};

solve();

module.exports = {
  solve,
  formatData,
  fewestButtonPressesForLights,
  maskLightDiagram,
  maskButtonSchematic,
  partOne,
  getButtonMap,
  mapJoltageMaximums,
  joltageTargetExceeded,
  joltageTargetMet,
  pressButton,
  fewestButtonPressesForJoltage,
  getButtonsToPress,
  comparator,
  partTwo,
};
